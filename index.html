<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - orbit controls</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				color:#000;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: red;
			}

      video {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0px;
        left: 0px;
        z-index: -500;
      }

      .container {
        position: absolute;
        top: 0px;
        left: 0px;
      }
		</style>
	</head>

	<body>
    <video autoplay></video>
		<div id="container">
      <h1 id="loading">Please face north.</h1>
      <button onclick="run()"
    </div>
		<script src="https://threejs.org/build/three.js"></script>
		<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
		<script src="https://threejs.org/examples/js/controls/DeviceOrientationControls.js"></script>
		<script src="https://threejs.org/examples/js/Detector.js"></script>
		<script src="https://threejs.org/examples/js/libs/stats.min.js"></script>
    <script src="https://wzrd.in/standalone/three-text2d@latest"></script>

		<script>

function run() {

var haversine = (function () {
  // convert to radians
  var toRad = function (num) {
    return num * Math.PI / 180
  }

  return function haversine (start, end, options) {
    options   = options || {}

    var radii = {
      km:    6371,
      mile:  3960,
      meter: 6371000,
      nmi:   3440
    }

    var R = options.unit in radii
      ? radii[options.unit]
      : radii.km

    var dLat = toRad(end.latitude - start.latitude)
    var dLon = toRad(end.longitude - start.longitude)
    var lat1 = toRad(start.latitude)
    var lat2 = toRad(end.latitude)

    var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2)
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))

    if (options.threshold) {
      return options.threshold > (R * c)
    }

    return R * c
  }
})();





let points, info, angles, distances;

const geoUpdated = ({coords: {latitude, longitude}}) => {
  console.log(latitude, longitude);
  localStorage.geo = JSON.stringify({latitude, longitude});

  fetch(`https://cors-anywhere.herokuapp.com/en.wikipedia.org/w/api.php?action=query&list=geosearch&gsradius=10000&gscoord=${latitude}|${longitude}&format=json`).then(resp => {
    return resp.json();
  }).then(json => {
    // Get all geolocations
    points = json.query.geosearch;

    // Fetch urls for each point
    const ids = points.map(i => i.pageid).join('|');
    return fetch(`https://cors-anywhere.herokuapp.com/en.wikipedia.org/w/api.php?action=query&prop=info&pageids=${ids}&inprop=url&format=json`);
  }).then(resp => {
    return resp.json();
  }).then(json => {
    info = json.query.pages;

    // Get distances from current position to the landmark
    return points.map(point => {
      return haversine({latitude, longitude}, {latitude: point.lat, longitude: point.lon}, {unit: 'meter'});
    });
  }).then(pos => {
    distances = pos;
    return points.map(p => {
      return Math.atan((longitude - p.lon) / (latitude - p.lat));
    });
  }).then(a => {
    angles = a;

    return angles.map((deg, ct) => {
      return {x: distances[ct] * Math.sin(deg), y: distances[ct] * Math.cos(deg)};
    });
  }).then(positionsOfLandmarks => {
    console.log(positionsOfLandmarks);
    var loading = document.getElementById("loading");
    loading && loading.remove();

    init(positionsOfLandmarks);
    animate();
  });
};

navigator.geolocation.watchPosition(geoUpdated);

if (localStorage.geo) {
  geoUpdated({coords: JSON.parse(localStorage.geo)});
}




function makeTextSprite( message, parameters ) {
	if ( parameters === undefined ) parameters = {};
	
	var fontface = parameters.hasOwnProperty("fontface") ? 
		parameters["fontface"] : "Arial";
	
	var fontsize = parameters.hasOwnProperty("fontsize") ? 
		parameters["fontsize"] : 18;
	
	var borderThickness = parameters.hasOwnProperty("borderThickness") ? 
		parameters["borderThickness"] : 4;
	
	var borderColor = parameters.hasOwnProperty("borderColor") ?
		parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };
	
	var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?
		parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };

	var canvas = document.createElement('canvas');
	var context = canvas.getContext('2d');
	context.font = "Bold " + fontsize + "px " + fontface;
    
	// get size data (height depends only on font size)
	var metrics = context.measureText( message );
	var textWidth = metrics.width;
	
	// background color
	context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + ","
								  + backgroundColor.b + "," + backgroundColor.a + ")";
	// border color
	context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + ","
								  + borderColor.b + "," + borderColor.a + ")";

	context.lineWidth = borderThickness;
	// 1.4 is extra height factor for text below baseline: g,j,p,q.
	
	// text color
	context.fillStyle = "rgba(0, 0, 0, 1.0)";

	context.fillText( message, (canvas.width - textWidth) / 2, fontsize + borderThickness);
	
	// canvas contents will be used for a texture
	var texture = new THREE.Texture(canvas) 
	texture.needsUpdate = true;

	var spriteMaterial = new THREE.SpriteMaterial( 
		{ map: texture, useScreenCoordinates: false} );
	var sprite = new THREE.Sprite( spriteMaterial );
	sprite.scale.set(100, 50, 1.0);
	return sprite;	
}



let alreadyRendered = [];


if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

var stats;

var camera, controls, scene, renderer;

scene = new THREE.Scene();
scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

renderer = new THREE.WebGLRenderer({alpha: true});
// renderer.setClearColor( scene.fog.color );
// renderer.setClearColorHex( 0xffffff, 1 );
renderer.setClearColor( 0x000000, 0 ); // the default
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setSize( window.innerWidth, window.innerHeight );

var container = document.getElementById( 'container' );
container.appendChild( renderer.domElement );

camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
camera.position.x = 0;
camera.position.y = 0;
camera.position.z = 5;

// controls = new THREE.OrbitControls( camera, renderer.domElement );
controls = new THREE.DeviceOrientationControls( camera );
// controls.addEventListener( 'change', render ); // remove when using animation loop
// controls.connect()
// enable animation loop when using damping or autorotation
//controls.enableDamping = true;
//controls.dampingFactor = 0.25;
controls.enableZoom = false;

// world
var geometry = new THREE.SphereGeometry(5, 32, 32);
var material =  new THREE.MeshPhongMaterial( { color:0xffffff, shading: THREE.FlatShading } );

// var origin = new THREE.Mesh(geometry, material);
// origin.position.x = 0;
// origin.position.y = 0;
// origin.position.z = 0;
// origin.updateMatrix();
// origin.matrixAutoUpdate = false;
// scene.add(origin);

// lights

light = new THREE.DirectionalLight( 0xffffff );
light.position.set( 1, 1, 1 );
scene.add( light );

light = new THREE.DirectionalLight( 0x002288 );
light.position.set( -1, -1, -1 );
scene.add( light );

light = new THREE.AmbientLight( 0x222222 );
scene.add( light );

//


					    var setScreenOrientation = function() {
						        window.setTimeout(function() {
						          renderer.domElement.style['MozTransform'] =
						            renderer.domElement.style['MsTransform'] =
						              renderer.domElement.style['WebkitTransform'] =
						                renderer.domElement.style['OTransform'] =
						                  renderer.domElement.style['Transform'] =
						                    "rotate(" + ( -window.orientation || 0 ) + "deg)";
						        }, 200);
					    };

					    window.addEventListener('orientationchange', setScreenOrientation, false);

//

window.addEventListener( 'resize', onWindowResize, false );



function init(positionsOfLandmarks) {
  alreadyRendered.forEach(i => scene.remove(i));
  alreadyRendered = [];

  positionsOfLandmarks.forEach(({x, y}, ct) => {
    var mesh = new THREE.Mesh( geometry, material );
    mesh.position.x = x;
    mesh.position.y = 0;
    mesh.position.z = y;
    mesh.updateMatrix();
    mesh.matrixAutoUpdate = false;
    scene.add(mesh);
    alreadyRendered.push(mesh);

    var spritey = makeTextSprite(points[ct].title, {
      fontsize: 12, borderColor: {r:255, g:0, b:0, a:0}, backgroundColor: {r:255, g:100, b:100, a:0.8} } );
    spritey.position.set(x, 5, y);
    scene.add( spritey );
    alreadyRendered.push(spritey);
  });
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize( window.innerWidth, window.innerHeight );
}

function animate() {
  requestAnimationFrame( animate );
  controls.update(); // required if controls.enableDamping = true, or if controls.autoRotate = true
  render();
}

function render() {
  renderer.render( scene, camera );
}

navigator.mediaDevices.getUserMedia({
  video: {
    facingMode: { exact: "environment" },
  },
}).then(localMediaStream => {
  var video = document.querySelector('video');
  video.src = window.URL.createObjectURL(localMediaStream);
});

}
		</script>

	</body>
</html>
