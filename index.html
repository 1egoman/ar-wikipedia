<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - orbit controls</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				color:#000;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: red;
			}

      video {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0px;
        left: 0px;
        z-index: -500;
      }

      .container {
        position: absolute;
        top: 0px;
        left: 0px;
      }
		</style>
	</head>

	<body>
    <video autoplay></video>
		<div id="container">
      <h1 id="loading">
        Please face north.
        <button onclick="run()">Facing north</button>
      </h1>
    </div>

		<script src="https://threejs.org/build/three.js"></script>
		<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
		<script src="https://threejs.org/examples/js/controls/DeviceOrientationControls.js"></script>
		<script src="https://threejs.org/examples/js/Detector.js"></script>
		<script src="https://threejs.org/examples/js/libs/stats.min.js"></script>
    <script src="https://wzrd.in/standalone/three-text2d@latest"></script>

		<script>

const haversine = (function () {
  // convert to radians
  var toRad = function (num) {
    return num * Math.PI / 180
  }

  return function haversine (start, end, options) {
    options   = options || {}

    var radii = {
      km:    6371,
      mile:  3960,
      meter: 6371000,
      nmi:   3440
    }

    var R = options.unit in radii
      ? radii[options.unit]
      : radii.km

    var dLat = toRad(end.latitude - start.latitude)
    var dLon = toRad(end.longitude - start.longitude)
    var lat1 = toRad(start.latitude)
    var lat2 = toRad(end.latitude)

    var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2)
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))

    if (options.threshold) {
      return options.threshold > (R * c)
    }

    return R * c
  }
})();

// Globals for storing data to render
let points, info, angles, distances;

// Render three.js things!
let camera, controls, scene, renderer, geometry;

// Store all 3d things that are rendered to the canvas at any given time so we can easily clear the
// screen.
let alreadyRendered = [];

function geoUpdated({coords: {latitude, longitude}}) {
  console.log(latitude, longitude);
  localStorage.geo = JSON.stringify({latitude, longitude});

  fetch(`https://cors-anywhere.herokuapp.com/en.wikipedia.org/w/api.php?action=query&list=geosearch&gsradius=10000&gscoord=${latitude}|${longitude}&format=json`).then(resp => {
    return resp.json();
  }).then(json => {
    // Get all geolocations
    points = json.query.geosearch;

    // Fetch urls for each point
    const ids = points.map(i => i.pageid).join('|');
    return fetch(`https://cors-anywhere.herokuapp.com/en.wikipedia.org/w/api.php?action=query&prop=info&pageids=${ids}&inprop=url&format=json`);
  }).then(resp => {
    return resp.json();
  }).then(json => {
    info = json.query.pages;
    console.log(info)

    // Get distances from current position to the landmark
    return points.map(point => {
      return haversine({latitude, longitude}, {latitude: point.lat, longitude: point.lon}, {unit: 'meter'});
    });
  }).then(pos => {
    distances = pos;
    return points.map(p => {
      return Math.atan((longitude - p.lon) / (latitude - p.lat));
    });
  }).then(a => {
    angles = a;

    return angles.map((deg, ct) => {
      // return {x: distances[ct] * Math.sin(deg), y: distances[ct] * Math.cos(deg)};
      return {x: distances[ct] * Math.cos(deg), y: distances[ct] * Math.sin(deg)};
    });
  }).then(positionsOfLandmarks => {
    console.log(positionsOfLandmarks);
    var loading = document.getElementById("loading");
    loading && loading.remove();

    console.log(positionsOfLandmarks)
    renderLandmarks(positionsOfLandmarks);
    animate();
  });
};

function makeTextSprite( message, parameters ) {
	if ( parameters === undefined ) parameters = {};
	
	var fontface = parameters.hasOwnProperty("fontface") ? 
		parameters["fontface"] : "Arial";
	
	var fontsize = parameters.hasOwnProperty("fontsize") ? 
		parameters["fontsize"] : 18;
	
	var borderThickness = parameters.hasOwnProperty("borderThickness") ? 
		parameters["borderThickness"] : 4;
	
	var borderColor = parameters.hasOwnProperty("borderColor") ?
		parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };
	
	var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?
		parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };

	var canvas = document.createElement('canvas');
	var context = canvas.getContext('2d');
	context.font = "Bold " + fontsize + "px " + fontface;
    
	// get size data (height depends only on font size)
	var metrics = context.measureText( message );
	var textWidth = metrics.width;
	
	// background color
	context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + ","
								  + backgroundColor.b + "," + backgroundColor.a + ")";
	// border color
	context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + ","
								  + borderColor.b + "," + borderColor.a + ")";

	context.lineWidth = borderThickness;
	// 1.4 is extra height factor for text below baseline: g,j,p,q.
	
	// text color
	context.fillStyle = "rgba(0, 0, 0, 1.0)";

	context.fillText( message, (canvas.width - textWidth) / 2, fontsize + borderThickness);
	
	// canvas contents will be used for a texture
	var texture = new THREE.Texture(canvas) 
	texture.needsUpdate = true;

	var spriteMaterial = new THREE.SpriteMaterial( 
		{ map: texture, useScreenCoordinates: false} );
	var sprite = new THREE.Sprite( spriteMaterial );
	sprite.scale.set(100, 50, 1.0);
	return sprite;	
}

function renderLandmarks(positionsOfLandmarks) {
  alreadyRendered.forEach(i => scene.remove(i));
  alreadyRendered = [];

  positionsOfLandmarks.forEach(({x, y}, ct) => {
    var mesh = new THREE.Mesh( geometry, material );
    mesh.position.x = x;
    mesh.position.y = 0;
    mesh.position.z = y;
    mesh.updateMatrix();
    mesh.matrixAutoUpdate = false;
    scene.add(mesh);
    alreadyRendered.push(mesh);

    var spritey = makeTextSprite(points[ct].title, {
      fontsize: 16,
      borderColor: {r:255, g:0, b:0, a:0},
      backgroundColor: {r:255, g:100, b:100, a:0.8}
    });
    spritey.position.set(x, 5, y);
    scene.add( spritey );
    alreadyRendered.push(spritey);
  });
}

function animate() {
  requestAnimationFrame( animate );
  controls.update(); // required if controls.enableDamping = true, or if controls.autoRotate = true
  render();
}

function render() {
  renderer.render( scene, camera );
}


function run() {
  // When geolocation updates...
  navigator.geolocation.watchPosition(geoUpdated);

  // Optimistic updates.
  if (localStorage.geo) {
    geoUpdated({coords: JSON.parse(localStorage.geo)});
  }

  // Insert video into the background
  navigator.mediaDevices.enumerateDevices().then(devs => {
    // Prefer a back camera.
    const back = devs.find(i => i.label.indexOf('back') >= 0) ||
      devs.find(i => i.kind.indexOf('video') >= 0); // but fall back on the first device that broadcasts video

    return navigator.mediaDevices.getUserMedia({
      video: {
        deviceId: {exact: back.deviceId},
      },
    });
  }).then(localMediaStream => {
    var video = document.querySelector('video');
    video.src = window.URL.createObjectURL(localMediaStream);
  });



  if (!Detector.webgl) Detector.addGetWebGLMessage();

  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

  renderer = new THREE.WebGLRenderer({alpha: true});
  renderer.setClearColor( 0x000000, 0 ); // the default
  renderer.setPixelRatio( window.devicePixelRatio );
  renderer.setSize(window.innerWidth, window.innerHeight);

  let container = document.getElementById( 'container' );
  container.appendChild( renderer.domElement );

  camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
  camera.position.x = 0;
  camera.position.y = 0;
  camera.position.z = 1;

  controls = new THREE.DeviceOrientationControls( camera );
  controls.enableZoom = false;

  // world
  geometry = new THREE.SphereGeometry(5, 32, 32);
  material = new THREE.MeshPhongMaterial({
    color: 0xffffff,
    shading: THREE.FlatShading
  });

  // lights
  light = new THREE.DirectionalLight(0xffffff);
  light.position.set(1, 1, 1);
  scene.add(light);

  light = new THREE.DirectionalLight(0x002288);
  light.position.set(-1, -1, -1);
  scene.add(light);

  light = new THREE.AmbientLight(0x222222);
  scene.add(light);



  // When the user rotates their device, rotate the canvas to offset in the other direction.
  window.addEventListener('orientationchange', () => {
    window.setTimeout(function() {
      document.body.style['MozTransform'] =
      document.body.style['MsTransform'] =
      document.body.style['WebkitTransform'] =
      document.body.style['OTransform'] =
      document.body.style['Transform'] =
      `rotate(${-window.orientation || 0}deg)`;
    }, 200);
  }, false);
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize( window.innerWidth, window.innerHeight );
  }, false );




}
		</script>

	</body>
</html>
